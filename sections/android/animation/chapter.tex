% !TeX spellcheck = da_DK

\chapter{Animation}
Animation handler om at få ting til at bevæge sig og ændre udseende. Mere specifikt lærer I at få Views til at flytte sig på skærmen, rotere, ændre størrelse og på andre måder ændre udseende.
\section{Grundlæggende teori om animation}
Før vi går igang med at lave animationer i Android skal vi lige have på plads hvordan animationer virker.
Animationer og video generelt er en række af billeder som skifter så hurtigt at det ligner en flydende bevægelse. \\
%Illustration af still frames i række
Når man laver en animation foregår det altså ved at man laver små ændringer af billedet så hurtigt efter hinanden at det bliver "flydende". En anden måde at sige det på er at billedet ændrer sig i små hak, og man gør de hak så små at det ikke kan ses at der arbejdes i hak. \\
Grunden til at man arbejder i hak er at det tager en hel del arbejde for en computer \marginnote{En mobil er også en computer} at udregne hvordan den skal vise et billede, så det gælder om at finde en balance mellem udseende og hvor meget af computerens regnekraft animationen tager. Det animation vi arbejder med har nu et fastsat tempo for hvor hurtigt billedet ændrer sig, så det skal I ikke overveje.
\subsection{Animationens rammer}
En animation starter et sted og slutter på et andet sted. Det kan både være at den ændrer sin position på skærmen, at starter med at være lille og slutter med at være stor eller at det er et ImageView som går igennem en række billeder i resource mappen. \\
%Illustration af ansigt der ændrer sig
Animationen tager også et stykke tid. Det kunne være et halvt sekund eller ti sekunder det tager for den at nå fra start til slut. Her gælder det om at lave en balance mellem at animationen tager tid nok så brugeren kan nå at se hvad der sker, og at brugeren ikke sidder og venter på at animationen bliver færdig. Hvis der ikke er stor forskel på start og slut i din animation kan det være at det slet ikke er nødvendigt at sætte en animation op, men bare at sætte dit View til slutpunktet med det samme. \marginnote{Hvis du bare vil have en oversigt over mulighederne for et view så se sektionen "Hvad kan vi ændre"} \\
Ud fra disse rammer kan vi så regne hvor langt vi skal være nået på et givet tidspunkt i animationen. 
\begin{example}
	Vi skal rykke et View fra 30 til 50 pixels horizontalt på 2 sekunder. Vi skal vide hvilken pixel vi er kommet til efter 0,5 sekunder, 1 sekund, 1,23 sekunder etc. Det vi kan gøre er at plotte en funktion, hvilket er meget simpelt hvis den er lineær:
	\begin{equation}
	pixel=10\cdot tid+30
	\end{equation}
	Hvor 10 er antallet af pixels Viewet bevæger sig i sekundet og 30 er startværdien
\end{example}
Vi skal nu ikke til at udregene en hel masse funktioner for animationen. Det gør Android for os.
\section{En helt simpel animation i Android}
For at lave en animation bruger vi den klasse der hedder ValueAnimator. Du kan tænke på et objekt af ValueAnimator som en animation. Du opretter en ValueAnimator således:
\begin{JavaCode}{Oprettelse af ValueAnimator}{animation1}
	ValueAnimator minAnimation = ValueAnimator.ofInt(startInt, slutInt);
\end{JavaCode}
\marginnote{Noter at du ikke skal skrive new. Den tekniske grund hertil er at ofInt() er en metode som returnerer en ny ValueAnimator.}
ofInt() tager to integers som er din startværdi og din slutværdi. Det kunne f.eks. være 0 og 360 hvis man ville lave en animere et View til at rotere 360 grader. \\
Det næste din animation har brug for er hvor lang tid den skal køre. Den sættes således:
\begin{JavaCode}{Sæt duration}{animation2}
	minAnimation.setDuration(1000);	
\end{JavaCode}
Tiden er i millisekunder. Altså betyder 1000 et sekund. Fem sekunder ville være 5000 og et kvart sekund ville være 250. Værdien skal være af typen long. Altså et heltal.
\subsection{At lave et billede}
Nu har vi fortalt Android hvor den skal starte og slutte, og hvor lang tid animationen skal tage. Det den så gør er at hver gang det er tid til at udregne et nyt billede, kalder den en funktion som vi definerer. Altså skal vi programmere hvad der sker hver gang det er tid til et nyt billede. Koden ser således ud:
\begin{JavaCode}{Opsæt metode til at lave et billede}{animation3}
	minAnimation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
		@Override
		public void onAnimationUpdate(ValueAnimator animation) {
			int vaerdiTilBillede = (int) animation.getAnimatedValue();
			
			mitView.setRotation(vaerdiTilBillede);
		}
	});
\end{JavaCode}
Hvad der sker er lidt advanceret og I behøver ikke at forstå det. Den korte version er at vi opretter et objekt af en ny klasse og fortæller ValueAnimator at den skal kalde onAnimationUpdate() i dette objekt når den vil have et nyt billede.\\
\marginnote{Hvis I vil have den længere udgave så spørg os eller internettet om anonyme klasser}
Det der er vigtigt at forstå er at det der skal ændres for det nye billede skal skrives i onAnimationUpdate(). I eksemplet sætter jeg rotationen af et View. \\
Men hvordan ved vi hvor langt i animationen vi er nået? Det ved Android, og den har også lavet en funktion for at give den værdi vi skal bruge istedet for tiden der er gået. Du får den ved at kalde getAnimatedValue() som der står i koden ovenover. Så kan du bruge den værdi til lige det du vil. Mulighederne for det kommer om lidt. \\
Til sidst skal du kalde .start() på din ValueAnimator og så kører animationen. Her er et fuldt eksempel på en animation: 
\begin{JavaCode}{420 Rotate it}{animation4}
	ValueAnimator minAnimation = ValueAnimator.ofInt(0, 420);
	minAnimation.setDuration(1337);
	minAnimation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
		@Override
		public void onAnimationUpdate(ValueAnimator animation) {
			int vaerdiTilBillede = (int) animation.getAnimatedValue();
			mitView.setRotation(vaerdiTilBillede);
		}
	});
	minAnimation.start();
\end{JavaCode}
Du kan nu lave animationer i Android. Huzzah!
\section{Flere grundteknikker}
Nu hvor det helt basale er på plads kan vi udvide med nogle flere teknikker
\subsection{Størrelsen af skærmen}
Der findes mange forskellige Android mobiler, og de har mange forskellige skærmstørrelser, især hvis man også arbejder med tablets. 
\begin{example}
	Den mobil I arbejder med har en skærmbredde på 480 pixels. I har et view som skal krydse skærmen og sætter det til at starte i 0 og bevæge sig 480 pixels. Og det virker lige som det skal på jeres test mobil. I prøver så at køre appen på en tablet med en skærmbredde på 1080 pixels. Jeres view når ikke engang halvvejs over skærmen. 
\end{example}
Det gælder derfor om altid at arbejde ud fra skærmens størrelse. Jeres view i eksemplet skal bevæge sig en hel skærmbredde. En figur som står i baggrunden og hopper skal hoppe 1/3 af skærmenhøjden. Etc.\\

Og siden skærmstørrelsen er så kritisk skulle man tro at den var lettere at få fat på. Men nej, koden for at få skærmstørrelsen ser således ud:
%TODO få det her til at virke
%\begin{JavaCode}
%	final View layout = findViewById(R.id.layout);
%	ViewTreeObserver observer = layout.getViewTreeObserver();
%	observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
%		@Override
%		public void onGlobalLayout() {
%			screenHeight = layout.getHeight();
%			screenWidth = layout.getWidth();
%			
%			boardLayout.getViewTreeObserver().removeOnGlobalLayoutListener(this);
%		}
%	});
%\end{JavaCode}

Dette skal stå inde i onCreate(). I skal også give jeres yderste layout et ID og hente det med findViewByID(). Og så skal i have screenHeight og screenWidth som feltvariabler. Og hvis I skal bruge størrelsen af skærmen i onCreate() skal den kode også stå inde i onGlobalLayout().
Grunden hertil er at Android ikke har udregnet hvordan grafikken placeres når OnCreate bliver kaldt. Vi får den så til at kalde onGlobalLayout når den har fundet størrelsen af layoutet.
\subsection{Interpolatorer}
Det vi har defineret for Android er egentlig kun startpunkt, slutpunkt og tid imellem dem. Hvordan funktionen mellem de to punkter ser ud kan også defineres. Det kan være at den bare er lineær, men den kunne også være en exponentionel funktion hvor hastigheden starter med at være er langsom og så derefter bliver hurtigere. 
Hvis du ikke sætter en interpolator så vil Android bruge AccelerateDecelerateInterpolator. Altså vil hastigheden for animationen være langsommere i starten og slutningen og så være hurtig i midten. Du sætter en interpolator således: \\
%TODO: Javakode med setInterpolator
\\
De helt basale muligheder er LinearInterpolator, AccelerateInterpolator, DecelerateInterpolator og så selvfølgelig AccelerateDecelerateInterpolator. Der findes dog flere som man kan finde online.
%Illustrationer tii interpolators
\subsection{Hvad kan vi ændre}
Her er der så en liste over hvad man kan lave med Views:
\begin{itemize}
	\item Rotation \\
		I kan sætte et views rotation med: \\
		%TODO javakode.
			mitView.setRotation(jeresRotation);\\
		Rotationen er i grader. 0 er normal rotation og 180 grader er på hovedet. Rotationen er en float.
	\item Position \\
		Her sættes vertikal og horizontal position seperat. Koden er således:\\
			mitView.setTranslationX(jeresPositionX);\\
			mitView.setTranslationY(jeresPositionY);\\
		Her skal det noteres at det er \textbf{øverste} venstre hjørne der er position (0,0). Ligeledes er det viewets øverste venstre hjørne der placeres. Hvis I vil placere et view op af skærmens højre side skal i altså sætte X til skærmbredden minus viewets bredde. I kan få bredden af jeres view med:\\
			mitView.getWidth();\\
	\item Størrelse
		I kan sætte størrelsen med: \\
		mitView.setScaleX(jeresStoerlseX);\\
		mitView.setScaleY(jeresStoerlseY);\\
		Her er 1 den størrelse som viewet starter med. Skal størrelsen fordobles skal I give slutværdien 2. Skal den halveres skal I give slutværdi 0.5 etc.
	\item Gennemsigtighed
		Et view kan gøres gennemsigtigt (Man kan stadig interagere med det) med denne metode:\\
		mitView.setAlpha(jeresGennemsigtighed);\\
		Her er 0 usynlig og 1 er fuldt synlig. Værdien som tages er selvfølgelig en float.
\end{itemize}
\subsection{Ændring af billeder}
Hvis man vil ændre billedet i et ImageView kræver det lidt mere arbejde. 
%TODO. SKal lige teste det her
\subsection{Startdelay, pause, resume og andre kontrolmetoder}
Animator har yderligere en række metoder som går den lettere at arbejde med. Du kan sætte animationen til først at starte noget tid efter at du kalder .start() ved at kalde: \\
minAnimation.setStartDelay(minForsinkelse);
Forsinkelsen er igen i millisekunder, præcist som setDuration. 
Yderligere er der metoderne .pause(), .resume(), .cancel,  .end() og .reverse() som meget vel giver sig selv. .end() sætter animationen til slutværdien mens de andre efterlader animationen ved den værdi den er på når de bliver kaldt.
\section{Mere advancerede teknikker}
Her kommer vi omkring nogle lidt mere advancerede teknikker
\subsection{Flere animationer samlet}
Vi kan samle flere animationer i en, så vi kan flytte vores view diagonalt, eller få det til at ændre farve og rotere samtidig. Til dette bruger vi AnimatorSet. Det virker sådan her:\\
%TODO javaCode
	AnimatorSet mitAnimationSet = new AnimatorSet();
	mitAnimatorSet.playTogether(minAnimation, minAndenAnimation);
	mitAnimatorSet.start();
Vi laver altså et AnimatorSet og så kalder vi .playTogether() med vores animationer som argumenter. Derefter starter vi vores sæt af animationer. Her skal det noteres at AnimatorSet opfører sig meget ligesom ValueAnimator og man kan stadig pause den og give den et startDelay m.m. 
Desuden kan man lave et AnimatorSet af andre AnimatorSets. Altså give et AnimatorSet som parameter til .playTogether(). Man kan desuden give playTogether lige så mange animationer som man har lyst til.\\
%TODO javaCode
	mitAnimatorSet.playTogether(minAnimation, minAndenAnimation, hans, grete);

\subsection{Animationer i rækkefølge}
Vi kan også spille animationer efter hinanden. Her bruger vi igen AnimatorSet:
%TODO javaCode
	AnimatorSet mitAnimationSet = new AnimatorSet();
	mitAnimatorSet.playSequentially(minAnimation, minAndenAnimation);
	mitAnimatorSet.start();
Så kører minAnimation først og derefter kører minAndenAnimation. Igen kan man give lige så mange animationer som man vil. 
%todo javacode
	mitAnimatorSet.playSequentially(minAnimation, minAndenAnimation, minTrejdeAnimation);
\subsection{Gentagelser}
Vi kan også sætte vores animationer til at gentage. Det er meget simpelt:
%todo javacode
	minAnimation.setRepeatCount(antalGentagelser);
Her er det værd at notere at hvis man sætter antalGentagelser til 1 så afspiller animationen \textbf{2 gange} i alt.
Man kan også sætte at:
%todo javacode
	minAnimation.setRepeatMode(ValueAnimator.REVERSE);
Hvilket gør at den på gentagelsen ikke går tilbage og kører forfra, men går fra slutværdien til startværdien. Den vil så igen gå fra start til slut på anden gentagelse etc.
\section{Hurtig guide} %TODO bedre navn
Her er en lille 4 skridts guide til at lave en animation.
\begin{enumerate}
	\item Opret en ValueAnimator med enten ofInt() eller ofFloat() \\
		%todo javacode
		ValueAnimator minAnimation = ValueAnimator.ofInt(startInt, slutInt);
	\item Sæt en varighed i millisekunder \\
		minAnimation.setDuration(varighed);
	\item Lav onAnimationUpdate og få den til at lave din ændring
		minAnimation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				int vaerdiTilBillede = (int) animation.getAnimatedValue();
				//Ændr dit view her
				mitView.setRotation(vaerdiTilBillede);
			}
		});
	\item Start animationen
		minAnimation.start();
\end{enumerate}
\section{Opgaver}
Der er ingen tid afsat til specifikt at lave opgaver i animation, men programmering er et praktisk fag så det gælder om at øve sig. Her er nogle forslag til ting at øve sig med.
\begin{exercise}
	Start helt fra bunden. Få en knap til at rotere 360 grader når du trykker på den.
\end{exercise}
\begin{exercise}
	Giv rotationen et startdelay så der går et øjeblik før den begynder at rotere.
\end{exercise}
\begin{exercise}
	Sæt din knap til at starte i venstre side af skærmen og så bevæge sig til midt på skærmen når du trykker på den.
\end{exercise}
\begin{exercise}
	Sæt bevægelsens interpolator til at være lineær
\end{exercise}
\begin{exercise}
	Kombiner de to første animationer så knappen først bevæger sig sidelæns og så derefter roterer
\end{exercise}
\begin{exercise}
	Sæt nu knappen til at starte i øverste højre hjørne. Få den til at bevæge sig lodret og vandret samtidigt til midt på skærmen, og derefter rotere en omgang. Noter hvordan at den lodrette bevægelse er starter og slutter langsomt fordi den bruger den normale interpolator mens den horizontale bevægelse er lineær
\end{exercise}
\begin{exercise}
	Få rotationen til at gentage sig selv 2 gange. Sæt derefter dens repeatMode til at være reverse.
\end{exercise}
\begin{exercise}
	TODO øvelse om billeder
\end{exercise}
\begin{exercise}
	Få helt styr på at arbejde med skærmens størrelse. Placer en knap i øverste venstre hjørne, og få den til at tage en runde langs telefonens kant når du trykker på den. 
\end{exercise}