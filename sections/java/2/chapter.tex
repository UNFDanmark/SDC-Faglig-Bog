
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tikz Intro:

\usetikzlibrary{shapes,arrows}

\tikzstyle{statement}  = [rectangle, draw, rounded corners, fill=blue!20, text centered, very thick, minimum size=1cm]
\tikzstyle{expression} = [ellipse, draw, text badly centered, fill=red!20, very thick, minimum size=1cm, text width=2cm]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Kontrol og Metoder}

	\todo{Java er smart, men ikke smart nok.}

	\todo{Baser opgaver på nogle af disse: \url{https://adriann.github.io/programming_problems.html}}

	\todo{Note til Lukas: Kan vi bruge en mono-spaced font til kode, både
	inline og til blokke? Den nuværende er hæslig til begge dele. Er meget tilfreds med lstautogobble!}

	\todo{Hvordan skriver vi til deltagerne? Skriver vi \emph{I}? Undgår vi at rette os mod dem?}

	\todo{@Beatrice: Kan du ikke tage for-each løkker? Måske som ekstra?}

    I sidste kapitel blev variabler, aritmetiske udtryk og
    \emph{if-statements} introduceret. Med disse dele kan man lave det
    der heder et \emph{straight-line program}, også kendt som kedelige
    programmer. Vi er ofte stillede over for opgaver som ikke kan
    løses ekslusivt med sådanne programmer. Vi behøver mere
    udtrykskraft, end hvad aritmetik og basal beslutningsevner kan
    give os.

    For eksempel vil vi gerne kunne sige ting som ``gør \emph{det her} indtil
	\emph{dette} sker'' eller ``gør \emph{dette}, først for \emph{1}, og så for
	\emph{2}, osv.''

	Af denne grund indeholder mange programmerings-sprog, inklusiv Java,
	mekanismer for at kunne udtrykke sådanne problemer, og det er disse
	mekanismer vi vil dække i dette kapitel.

	Det er vigtigt at tage i mende at programmører er dåvne dyr, og vil gerne
	udtrykke sig selv nemt. Derfor har Java rigtig mange mekanismer som teknisk
	set kan gøre det samme, men som er mere bekvemme i visse situationer.

    \todo{Find ud af hvad man kalder ``mekanismer''/dele af programmeringssprog, med et kort ord.}

    Dette kapitel vil dække mange af disse mekanismer. Du behøver ikke
    lære dem alle med de samme. Selv de bedste programmører glemmer
    hvordan man skriver nogle af disse. Følgende overordnet emner er
    dækket i dette kapitel:

	\begin{itemize} % Denne udgiver har også følgende selvhjælps-bøger på markedet:
		\item Løkker: Sådan får du mere kontrol
		\item Funktioner: Forbedre dine metoder
		\item Arrays: Få styr på dine variabler.
	\end{itemize}

\section{Løkker}

    En klassisk problemstilling er at gøre gentage noget kode en hvis
    mængden af gange. Der er mange løsninger, hvoraf løkker er en af
    de simpleste. I denne sektion dækker vi simple løkker og kigger
    lidt på nogle mere advanceret måder at bruge løkker på.

	\subsection{While-løkker}

        \JavaInline{while} er den simpleste type af løkke. Dette er ligesom at
		sige: ``Mens at A gælder, sørg for at gøre B.'' For eksempel:

		``Mens at gulvet er beskidt, bør du feje gulvet.''

		Dette er i modsætning til \JavaInline{if}-udstryk, hvor der udtrykkes
		``Hvis A gælder, gør B èn enkelt gang.''

		\todo{ Skal fyldes mere på. Sektion: \JavaInline{while} }

		\todo{ En illustration som denne kunne være brugbar:
		\url{https://upload.wikimedia.org/wikipedia/commons/4/43/While-loop-diagram.svg} }

		Anatomien af en \JavaInline{while}-udstryk er meget lig det af et
		\JavaInline{if}-udstryk, du skifter bare \JavaInline{if} ud med
		\JavaInline{while}, som kan ses i eksempel~\ref{lst:while-example-1}.

		\begin{JavaCode}{``Fej Gulvet'' pseudo-Java.}{lst:while-example-1}
			while (gulvet er beskidt) {
				fej gulvet;
			}
		\end{JavaCode}

        Man kalder koden mellem paranteserne for while-udtrykkets
        ``betingelse'', koden mellem tuborg-klammerne for ``kroppen''
        af \JavaInline{while}-udtrykket, og man kalder hver gennemgang
        af kroppen for en ``iteration''. Første gang løkken ses,
        kigges der på betingelsen, og hvis denne er \emph{sand} så
        køres kroppen, ellers hopper man over og fortsætter uden at
        køre løkken. Hvis man til gengæld har kørt kroppen, og er nået
        enden, så spørger man igen om betingelsen er \emph{sand}, hvis
        ja, kør kroppen igen, hvis ikke, fortsætter vi efter løkken.

        \begin{figure}
        \center
        \tikzstyle{flow} = [draw, very thick, rounded corners]
        \begin{tikzpicture}[node distance = 4cm, auto]
            \node[statement] (previous) {Tidligere kode};
            \node[expression, right of=previous] (condition) {Betingelse};
            \node[statement, below of=condition, node distance=1.5cm] (body) {Krop};
            \node[statement, right of=condition] (after) {Senere kode};

            \path [flow, ->] (previous.east) -- (condition.west);
            \path [flow, ->] (condition.east) -- node[auto, swap] {false} (after.west);
            \path [flow, <-] (condition.west) -- +(left:3mm) |- (body.west) ;
            \path [flow, ->] (condition.east) -- +(right:1mm) |- node {true} (body.east);
        \end{tikzpicture}
        \caption{While-løkker}
        \label{fig:while-loop-illustrated}
        \end{figure}


        Nu kan man spørge: ``Man kan vel lave en løkke, hvis
        betingelse altid er \emph{sand}? Et program som aldrig
        stopper, en uendelig løkke?'' Ja, det er faktisk ret nemt. Så
        nemt at alle programmører laver en nu og da, ved uheld.
        kommer til at lave en uønsket uendelig løkke, nu og da. Se
        eksempel~\ref{lst:while-hello-world} for et program som
        gentagende skriver ``hej''. Det er selvfølgelig ikke så
        brugbart et program, men det viser en problematik: Hvad gør vi
        hvis vores program aldrig stopper? \todo{Svar på ``Hvad gør vi
        hvis vores program aldrig stopper?''}

        \footnote{Dette stiller selvfølgelig spørgsmålet ``kan man
        lave et program som kan sige om et program stopper eller
        ej?''. Det er muligt at lave et program, som svarer for
        \emph{nogle} programmer, men umuligt at lave en som kan svare
        for \emph{alle} programmer.  (Læg mærke til at programmet
        skulle svare om det selv stoppede. Dette er del af beviset.)
        Denne problematik kaldes for \emph{The Halting Problem}, og
        blev bevist af \emph{Allan Turing}.}

		\begin{JavaCode}{Et program der aldrig ender.}{lst:while-hello-world}
			System.out.println("Hello World!");
			while (true) {
				System.out.println("Hello again!");
			}
		\end{JavaCode}

        Det giver sjældent mening at have sådanne uendelige
        løkker\footnote{De fleste programmer du kører på din computer
        eller smartphone har dog uendelige løkker, da disse alligevel
        skal køre indtil brugeren lukker dem.}, og de fleste løkkers
        betingelser blive \emph{falske} på et tidspunkt. I
        eksempel~\ref{lst:while-example-3} kan ses hvordan man kan
        tælle op fra 1 til 10.

		\begin{JavaCode}{Et ``brugbart'' while program.}{lst:while-example-3}
			int n = 1;
			while (n <= 10) {
				System.out.println(n + " linjer af ligegyldig data.");
				n++;
			}
		\end{JavaCode}

		\begin{exercise}
			Copenhagen Suborbitals har kontaktet dig, for at lave en maskine til
			at tæller ned fra 10, og vise "Affyring!", i stedet for 0.
		\end{exercise}

		\begin{exercise}
            Brug en \JavaInline{while}-løkke til at summerer tallene
            fra 1 til 100, og viser det.
		\end{exercise}

		\begin{exercise}
            Brug en \JavaInline{while}-løkke til at summerer tallene
            fra 1 til 100, og viser det, men ignorer tal der ikke
            deles af 3 eller 5. Så \(1, 2, 4, 7, 8, \dots\) skal ikke
            inkluderes, mens at \(3, 5, 6, 9, 10, 12, \dots\) skal.
		\end{exercise}

		\begin{exercise}
            Skriv et program som tæller op fra \(1\) til \(100\), og
            for hvert tal, vis tallet, og hvis det kan deles af 3 vis
            ``foo'', og hvis det kan deles af 5 vis ``bar''. Hvis det
            deles af både 3 og 5, vis ``foobar''.
		\end{exercise}

	\subsection{For-løkker}

		I sidste sektion så vi kan tælle op med et \JavaInline{while}-udtryk.
		Dette er da ikke en idéel måde at tælle på, da \JavaInline{n}
		defineres, sammenlignes og opdateres på helt forskellige steder i koden.
		Det kan blive svært at holde styr på i store programmer, hvilket er
		hvorfor Java har \JavaInline{for}-løkken, som samler den information i
		èt sted: \JavaInline{for (before_loop; condition_of_loop; after_every_iteration)}

		\todo{ Uddyb og udfyl. }

		Strukturen af for-løkker er ret involveret, men det hjælper at
		sammenligne med \JavaInline{while}-udstryk, og se hvordan at forskellige
		dele af koden som tidligere var sprædt, nu er samlet.

		\begin{JavaCode}{Et ``brugbart'' for program. Sammenlign med eksempel~\ref{while-example-3}.}{lst:for-example-1}
			for (int n = 1; n <= 10; n++) {
				System.out.println(n + " linjer af ligegyldig data.");
			}
		\end{JavaCode}

		\begin{exercise}
			Det er ofte fortalt hvordan at Gauss i sine unge dage, forpurrerede sin
			lærers plan om at få ham til at tie stille. Hun bedte ham lægge tallene
			fra \(1\) til \(100\) sammen, i håbet at dette ville optage det unge
			geni i lidt tid. Gauss realiserede dog at der måtte være en bedre måde
			at løse problemet på, og udledte formularen \(\frac{n\cdot(n+1)}{2}\).
			Han svarede hurtigt \(5050\), og så måtte læreren finde på en anden
			kedelig opgave.

			Brug et \emph{for-løkke} til at beregne \(1^2+2^2+\dots+100^2\).
		\end{exercise}

		\begin{exercise}
			Der er selvfølgelig ikke noget som forhindrer at du bruger et
			\emph{for-løkke} ind i et andet \emph{for-løkke}, og dette kan nogle gang
			være vældig praktisk.

			\todo{Find på opgave!}
		\end{exercise}

	\subsection{Break-udtryk}

		\todo{Udvid sektion}

		Sommetider vil man gerne gå ud af en løkke tidligt. Dette tillader
		\JavaInline{break}-keywordet os at gøre.

		\begin{JavaCode}{Et brugbart while program som stopper efter 10 linjer, på trods af et uendeligt løkke.}{lst:break-example-1}
			int n = 1;
			while (true) {
				System.out.println(n + " linjer af ligegyldig data.");
				n++;
				if (n == 10)  break;
			}
		\end{JavaCode}

        \todo{Tilføj en opgave, som viser at man godt kan klare sig
        uden break, men at break er pænere.}

		\todo{
			Som perspektiverende bonus kunne jeg tænke mig at fortælle lidt af
			historien om \emph{structured programming}, og hvorfor \JavaInline{goto}
			ikke er en ting i Java. \emph{Ikke pensum, bare for sjov.}
		}

	\subsection{!EXTRA! Do ... while}

		\todo{Udvid sektion}

		While-løkker tjekker om den burde fortsætte før iterationerne, men nogle
		gang vil vi gerne tjekke om vi fortsætter, efter vi har kørt
		iterationen. For eksempel kunne vi lave en beregning, og baseret på den
		beslutte om vi ville videre. Dette løser \emph{do-while} udtryk på en
		pæn måde.

		\begin{JavaCode}{Vil aldrig skrive ``Hej med dig''.}{lst:unknown-bc}
			while (false) {
				System.out.println("Hej med dig");
			}
		\end{JavaCode}

		\begin{JavaCode}{Vil skrive ``Hej med dig'' en enkelt gang.}{lst:unknown-b}
			do {
				System.out.println("Hej med dig");
			} while (false)
		\end{JavaCode}

		For eksempel:

		\begin{JavaCode}{Todo}{lst:unknown-c}
			String a = "";
			do {
				a = " " + a.length();
			} while (a.length <= 10);
			System.out.println(a);
		\end{JavaCode}

		\todo{Giv historien om at while-løkker var for dyre i forhold til do-while.}

	\subsection{Continue}

		I visse situationer giver det mening at hoppe over en iteration af en
		løkke. Dette kan gøres ved brug af \JavaInline{continue}-keyworded.

		\begin{JavaCode}{Kode der anvender \emph{continue} til at kun vise de lige tal.}{lst:unknown-a}
			for (int i = 1; i <= 10; i++) {
				if (i % 2 == 0)  continue;
				System.out.println(i);
			}
		\end{JavaCode}

		\todo{Skriv mere?}

        \todo{Tilføj en opgave, som viser at man godt kan klare sig
        uden continue, men at continue er pænere.}

\section{Funktioner}

	Sidste kapitel introducerede \emph{funktioner}\footnote{Også kaldet \emph{metoder} eller \emph{procedurer}.}
	som sorte-bokse, der gør arbejde for dig. For eksempel \JavaInline{Math.abs}
	som giver den absolutte værdi af hvadend den bliver givet. I denne sektion
	viser vi hvordan man laver sine egne funktioner, en færdighed som viser
	sig at være meget brugbar.

    Vi kalder hvad en funktion giver tilbage for dens
    \emph{retur-værdi} eller hvad funktionen \emph{returnerer}. Vi
    kalder hvad vi giver den, dvs. det som sættes mellem paranteser,
    for funktionens \emph{argumenter}.

    \todo{@Bamse: Dækker du disse definitioner?}
    \todo{@Beatrice: Husk at forklare \emph{private} og \emph{public}.}

	\todo{
		Denne sektion vil dække \emph{metode-definitioner}, \emph{retur-typer},
		\emph{argument-lister} og \JavaInline{return}.
		Jeg vil ikke dække statiske metoder, overloading, eller andre advanceret
		emner, da disse igen er ret niché, og kræver introduktion til nye
		koncepter.
	}

	\todo{Snak om Java-filer og deres forhold til funktioner?}

	\subsection{En funktions udseene}

		I har allerede set en funktion, nemlig \JavaInline{main}-funktionen, hvor i
		indtil videre har skrevet alle jeres programmer i:

		\begin{JavaCode}{Main funktion}{lst:main-function}
			public static void main(String[] args) {
				// Ting her...
			}
		\end{JavaCode}

		En funktion består af dens \emph{signatur} og dens \emph{krop}.

        Dens signatur er \JavaInline{public static void main(String[] args)}
        delen.  Dette fortælles os lidt om funktionen: dens
        navn \emph{main}; dens retur-værdi \emph{void} (ingenting); og
        dens argumenter \emph{String[] args}, hvilket er en liste af
        strenge, som funktionen kalder \emph{args}.  Signaturen for
        \emph{main} siger også at den er \emph{static} og
        \emph{public}. Disse egenskaber kan ignoreres for nu, da de
        først bliver relevant når man kender til klasser.

		En funktions krop er \JavaInline{// Ting her...} delen. Alt mellem
		krølleparanteserne er funktionens krop, og beskriver hvad funktionen gør.
		Hvis funktionen har en retur-værdi, skal \JavaInline{return}-keywordet opstå
		mindst én gang i kroppen. Det er denne som stopper funktionen, og returnerer.

        Signaturen er hvordan man skal snakke med funktionen, og
        kroppen er hvad den egentlig gør. Læg mærke til at hvis
        funktionen ikke skal have en retur-værdi, skal den gives
        retur-typen \emph{void}.

	\subsection{Eksempel funktion: faktoriel}

		Hvis vi skulle skrive \emph{faktoriel}-funktionen som en funktion i Java,
		ville vi først spørge os selv: ``hvad returnerer faktoriel og hvad er dens
		argumenter?'' Det virker måske trivielt, i dette eksempel, men stadig et
		vigtigt spørgsmål. Derefter skal vi spørge: ``Men hvad er det den gør?''

		Faktoriellen er defineret som \(a! = a \cdot (a-1) \cdot \dots \cdot 2 \cdot 1\),
		f.eks. \(5! = 5 \cdot 4 \cdot 3 \cdot 2 \cdot 1\). Ud fra definitionen er det
		tydeligt at den får et enkelt heltal, og giver et enkelt heltal tilbage. Så
		faktoriellens signatur ser sådan ud:

		\begin{JavaCode}{Signaturen af en faktoriel-funktion}{lst:factorial-signature}
			int factorial (int a)
		\end{JavaCode}

		Men hvad gør faktoriel funktionen? Den ganger det givne heltal med alle mindre
		heltal. Vi behøver at finde alle mindre heltal og gange det på. En version
		af faktorial-kroppen kunne ligne:

		\begin{JavaCode}{Kroppen af en faktoriel-funktion}{lst:factorial-body}
			int product = 1;
			for (int i = a; i >= 1; i--)
				product *= i;
			return product;
		\end{JavaCode}

        Læg mærke til \JavaInline{return}-keywordet. Denne siger ``nu
        er funktionen færdig'', og resultatet af funktionen er værdien
        der kommer lige bag efter \JavaInline{return}.

		Kombinationen af signaturen og kroppen resulterer i:

		\begin{JavaCode}{En faktoriel-funktion}{lst:factorial-function}
			int factorial (int a) {
				int product = 1;
				for (int i = a; i >= 1; i--)
					product *= i;
				return product;
			}
		\end{JavaCode}

        Nu kan man kalde overstående med eksempelvis
        \JavaInline{factorial(5)}, og få svar tilbage at dette er
        \(120\). Det er vigtigt at vide at overstående kunne have set
        meget anderledes ud, og stadig have været korrekt. Java har
        mange koncepter som er ekvivalente, og der er ingen bedste
        måde at gøre ting på.\footnote{Det er derfor at folk kalder
        programmering en kunst.}

        \todo{Tilføj 3-4 opgaver.}

        \begin{exercise}
            Lav en funktion med signaturen \JavaInline{void f ()}. Lad
            kroppen af denne funktion være et kald til funktionen
            selv. Sørg for at funktionen kaldes fra \JavaInline{main}.
            Hvad kunne der ske når koden køres? Hvad sker der når
            koden køres?
        \end{exercise}

    \subsection{!Extra! Call-by-reference}

        \todo{
            \emph{pass-by-value} vs. \emph{pass-by-reference} bør nok dækkes, da det
            garenteret vil dukke op. Det er bare ikke specielt relevant før de kender
            til objekter. Antager ikke de vil rende ind i problemet før under projektet.
            Jeg er ikke vild med at introducere dem til sådanne niché fagtermer, men
            det vil være nemmere for en hjælper at kunne sige ``læs dette stykke om
            hvorfor dit program ikke fungere korrekt.''
        }


        \begin{JavaCode}{Call-by-value demonsteret. Læg mærke til at værdien af \emph{num} ikke ændrer sig, når man ændrer i \emph{a}.}{lst:call-by-value-example}
            public int f (int a) {
                a += 2
                System.out.println("a is "+a);
            }

            public static void main(String[] args) {
                int num = 10;
                System.out.println("num is "+num);
                f(num);
                System.out.println("num is still "+num);
            }
        \end{JavaCode}

        \begin{JavaCode}{Call-by-reference demonsteret. Læg mærke til at når \emph{f} ændrer i værdien af \emph{a}, så ændrer den også i værdien af \emph{num}. Dette er fordi at \emph{num} og \emph{a} er de samme objekter i dette tilfælde.}{lst:call-by-value-example}
            public class Num {
                public int inner;
                public Num (int a) { inner = a; }
            }

            public int f (Num a) {
                a.inner += 2;
                System.out.println("a is "+a.inner);
            }

            public static void main(String[] args) {
                Num num = new Num(10);
                System.out.println("num is "+num.inner);
                f(num);
                System.out.println("num is still "+num.inner);
            }
        \end{JavaCode}

        Det vigtige at tage væk fra dette, er at når man kalder en
        funktion, så bliver typer der starter på et småt bogstav
        (\emph{int}, \emph{boolean}, \emph{float}) kopieret
        (\emph{call-by-value}), mens at typer der starter på store
        bogstaver (\emph{String}, \emph{List}) bliver ikke kopieret
        (\emph{call-by-reference}.)

        \todo{Tilføj en opgave eller to.}

	\subsection{!Extra! Rekursion}

        \todo{Dette kaldes rekursion, og det minder lidt om induktion, som i nok kender til

        -- Kurt til Datalogi-russerne, under deres først forelæsning.}

        En af opgaverne længere \todo{Ref til opgaven?} oppe
        involverer at lave en funktion som kalder sig selv. Dette er
        lidt sejt, da man ofte ser matematiske formler som udtrykkes i
        forhold til sig selv. For eksempel kan faktoriel funktionen
        udtrykkes matematisk som:

        \begin{equation}
            n! = \begin{cases}
                       1 & \text{hvis} \quad n = 1 \\
                       n\cdot(n-1)! & \text{ellers} \\
                  \end{cases}
        \end{equation}

        Denne måde at definere ting ud fra sig selv, kaldes for
        ``rekursion'', og sådanne objekter dukker ofte op i matematik
        og datalogi.

        \todo{Illustration: Sierpinski Trekanten}

        Selvom vi tidligere har skrevet en version af
        faktorial-funktionen som virker ved en \JavaInline{for}-løkke,
        kan vi sagtens lave version som kalder sig selv rekursivt. Se
        nedenfor. Læg mærke til hvor tæt på den overstående
        matematiske defintion, denne kode er:

        \begin{JavaCode}{Rekursiv Fakultet}{lst:factorial-recursive}
            public int factorial (int n) {
                if (n == 1)   return 1;
                return n * factorial(n-1);
            }
        \end{JavaCode}

        \begin{exercise}
            Fibonnaci sekvensen er en liste af tal (\(1, 1, 2, 3, 5,
            8, 13, 21, \dots\)), hvor de to første elementer er
            begge \(1\), og derefter er hvert element i listen,
            summen af de to foregående tal. Vi kan formulere dette
            matematisk som:

            \begin{equation}
                fib(n) = \begin{cases}
                             1                   & \text{hvis} \quad n = 1 \\
                             1                   & \text{hvis} \quad n = 2 \\
                             fib(n-2)+fib(n-1)   & \text{ellers} \\
                      \end{cases}
            \end{equation}

            Skriv din egen rekursive \JavaInline{fib} funktion i Java,
            ud fra overstånde definition. Hvis du har lyst, kan du
            bagefter forsøge en version uden rekursion.
        \end{exercise}


	\begin{exercise}
		Lige tal er de tal der kan deles med \(2\), dvs. \(0, 2, 4, \dots\).
		Ulige tal er så alle de andre heltal. Disse to mængder kan også defineres
		rekursivt.

		Vi ved at et tal er lige, hvis det forrige tal var ulige. Så hvis vi ved
		at \(5\) er ulige, så ved vi at \(6\) er lige. Ulige tal er omvendt, vi
		ved at \(5\) er ulige, hvis vi ved at \(4\) er lige.

		Men vi er nødt til at stoppe på et tidspunkt. Derfor definerer vi
		\(0\) til at være lige.

		Lav to funktioner \JavaInline{odd} og \JavaInline{even}, som modellere
		denne process ved at kalde hinanden. Begge bør tage et heltal, og give
		tilbage en boolesk værdi.

		\todo{
			Jeg er ikke helt tilfreds med denne opgave. (mutual) Rekursion er
			måske lidt for advanceret. Desuden tvivler jeg på at forholdet
			mellem lige og ulige tal forklares ordentligt. Syntes hellerer ikke
			at der lægges godt nok op til hvad de skal gøre.
		}

	\end{exercise}

	\todo{
		Vil gerne have en opgave som direkte takler hvordan funktioner og løkker
		er forskellige.

		``Kan jeg ikke bare gøre det med en for-løkke?''
	}

\section{Arrays}

	\todo{Denne sektion er omkring Arrays. Skriv den!}

	\todo{
		Lister er en fundamentel datastruktur, sandeligt er datamaten selv en
		kæmpe liste af data.
		Denne sektion vil dække arrays, f.eks. \JavaInline{int[]}.
		Kræver introduktion til arrays og subscripts.
	}

    Indtil videre har I kun arbejdet med enkelte værdier. Disse er
    brugbare, men hvad gør du hvis du har rigtig mange værdier? Har du
    en enkelt variable for hver værdi? Det bliver mange variabler, og
    store udtryk. Derfor er der noget der hedder \emph{arrays} ellers
    \emph{lister}. Disse har typen \JavaInline{undertype[]}. Læg mærke til
    \JavaInline|[]|-delen.

    For eksempel er en variable med typen \JavaInline{int[]} en liste
    af tal, og \JavaInline{String[]} er en liste af strenge. Vi kan
    tilgå element nummer \(n\) i listen \(a\) med \JavaInline{a[n]}.
    Lister i Java er underlige, de er nemlig nul-indekseret. Det betyder
    at det første element i listen har index \(0\), det andet element har
    index \(1\), ovs.\footnote{Tilbage i 1960erne, var det vigtigt at
    bruge computere så effektivt som muligt. Nogle kloge hoveder
    fandt ud af at det var hurtigere på deres computere at starte
    lister med 0. Nu-til-dags er det ikke meget hurtigere, og
    bibevares blot for traditionens skyld.}

    \begin{JavaCode}{Et eksempel på at arbejde med lister af tal. Læg specielt mærke til hvordan listen laves, og nul-indekseringen.}{lst:array-example}
        public static void main(String[] args) {
            int[] tal = new int[3];
            tal[0] = 10;
            tal[1] = 20;
            tal[2] = 30;
            for (i = 0; i < 3; i++) {
                System.out.println((i+1) + ". tal: "
                                         + tal[i]);
            }
        }
    \end{JavaCode}

    I tilfælde af at vi gerne vil finde længden af en liste, kan den findes med
    \JavaInline{a.length}.

    \begin{JavaCode}{Alternativ til overstående. Anvender alternativ måde at lave listen på, og bruger længden af listen, i stedet for en tilfældig konstant.}{lst:array-example-2}
        public static void main(String[] args) {
            int[] tal = { 10, 20, 30 };
            for (i = 0; i < tal.length; i++) {
                System.out.println((i+1) + ". tal: "
                                         + tal[i]);
            }
        }
    \end{JavaCode}


	\begin{exercise}
		Lav en funktion, som givet en liste af tal, finder det største tal i den
		liste.
	\end{exercise}

    \begin{exercise}
        Det er ikke muligt at gøre en liste mindre eller størrre efter
        den er skabt, den er evigt af en vis længde.  Det er dog
        muligt at lave en ny liste med en anden størrelse, og kopiere
        elementer fra den gamle ind i den nye.
        Lav en funktion \JavaInline{append} der tager en liste af tal
        \(l\), og et tal \(n\), og giver en ny liste af tal med \(n\)
        smidt på enden.
    \end{exercise}

    \begin{exercise}
        Det er muligt at have lister af lister. For eksempel
        \JavaInline{int[][]}.  Lav en funktion som givet en liste af
        lister af tal, finder det største tal i denne liste af lister
        af tal. Brug gerne jeres funktion fra overstående opgave.
    \end{exercise}

	\begin{exercise}
		\todo{Forbedre første sætning.}
		Et heltal \(n\) er et primtal, hvis det kun er \(1\) og \(n\) selv som
		deler \(n\). Disse tal var originalt en tal-teoretisk kuriositet, men
		anvendes nu til dags i kryptografien, hvor det er vigtigt at finde store
		primtal.

		En klassisk \emph{algoritme} til at finde primtal, kaldet
		\emph{Eratosthenes' si}, involverer at have en liste af heltal fra \(1\)
		til \(n\), hvor man starter med at fjerner alle multiplum af
		\(2, 3, 4, \dots, n\). Hvad man ender med til slut er en liste af primtal.

		Implementer \emph{Eratosthenes' si} op til \(100\) ved brug af et
		array, og to for-løkker. Bare sæt ikke-primtal til \(0\).
	\end{exercise}

    \begin{exercise}
        En alternative måde at finde primtal på, er at gå igennem alle
        tal, tjekke om det deles af en liste af primtal du allerede
        har. Hvis ikke så er det et primtal, og du tilføjer det til
        listen. Listen starter ud med at have tallene \(2\) og \(3\),
        men skal selvfølgelig have plads til at indeholde flere
        primtal.

        Find de første 100 primtal.
    \end{exercise}

\section{!Extra! Checked Exceptions}

	Nogle funktioner kan fejle, for eksempel hvis den gør ting over internettet.
	Men hvad skal Java gør hvis programmet fejler? Programmøren vil ofte gerne
	vide at der er en fejl, sådan at de kan fikse den. En mulighed er at give en
	unik retur-værdi, men dette er ikke altid muligt, alternativt kan man bare
	dræbe programmet, og give en sur fejl til programmøren, hvilket er simpelt,
	men ikke robust. Java har en helt tredje mulighed, den kan fange fejlene i
	en såkaldt ``try-catch'' kontrol-struktur:

	\begin{JavaCode}{Eh?}{lst:try-catch-example}
		try {
			// Ting her...
		} catch (<exception-type> e) {
			// Fiks fejlen
		}
	\end{JavaCode}

	Dette tillader os at ``fange'' fejl der opstår i \JavaInline{// Ting her...}
	delen, og gøre ting for at fikse fejlen i \JavaInline{// Fiks fejlen}.

	Denne kontrol-struktur er heldigvis ikke noget man normal behøver at bekymre
	sig om. Men Java er smart, og kan se når der er en mulighed for at opstå
	fejl, hvilket den vil klage over når du kompilerer dit program, ikke når du
	kører dit program. Dette kaldes \emph{checked exceptions}, og betyder at du
	sommetider er nødt til at lave en try-catch.

	\todo{Hej med dig, du er exceptions. Giv eksempel på I/O som kan fejle.}

    \todo{Tilføj en opgave eller to.}

