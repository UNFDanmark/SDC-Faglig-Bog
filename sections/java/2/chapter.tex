
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Kontrol og Metoder}

	\todo{Java er smart, men ikke smart nok.}

	\todo{Baser opgaver på nogle af disse: \url{https://adriann.github.io/programming_problems.html}}

	\todo{Note til Lukas: Kan vi bruge en mono-spaced font til kode, både
	inline og til blokke? Den nuværende er hæslig til begge dele. Er meget tilfreds med lstautogobble!}

	\todo{Hvordan skriver vi til deltagerne? Skriver vi \emph{I}? Undgår vi at rette os mod dem?}

	I sidste kapitel blev variabler, aritmetiske udtryk og \emph{if-statements}
	introduceret. Med disse dele kan man lave det der heder et
	\emph{straight-line program}. Men vi er ofte stillede over for problemer som
	ikke kan løses ekslusivt med sådanne programmer. Vi behøver mere
	udtrykskraft, end hvad aritmetik og basal beslutningsevner kan give os.
	For eksempel vil vi gerne kunne sige ting som ``gør \emph{det her} indtil
	\emph{dette} sker'' eller ``gør \emph{dette}, først for \emph{1}, og så for
	\emph{2}, osv.''

	Af denne grund indeholder mange programmerings-sprog, inklusiv Java,
	mekanismer for at kunne udtrykke sådanne problemer, og det er disse
	mekanismer vi vil dække i dette kapitel.

	Det er vigtigt at tage i mende at programmører er dåvne dyr, og vil gerne
	udtrykke sig selv nemt. Derfor har Java rigtig mange mekanismer som teknisk
	set kan gøre det samme, men som er mere bekvemme i visse situationer.

	Emner i dette kapitel:

	\begin{itemize} % Denne udgiver har også følgende selvhjælps-bøger på markedet:
		\item Løkker: Sådan får du mere kontrol
		\item Funktioner: Forbedre dine metoder
		\item Arrays: Få styr på dine variabler.
	\end{itemize}

\section{Løkker}

	\todo{Hvad gør jeg med for-each løkker?}

	\subsection{While-løkker}

		\JavaInline{while} er den simpleste af løkkerne. Dette er ligesom at
		sige: ``Mens at A gælder, sørg for at gøre B.'' For eksempel:

		``Mens at gulvet er beskidt, bør du feje gulvet.''

		Dette er i modsætning til \JavaInline{if}-udstryk, hvor der udtrykkes
		``Hvis A gælder, gør B èn enkelt gang.''

		\todo{ Skal fyldes mere på. Sektion: \JavaInline{while} }

		\todo{ En illustration som denne kunne være brugbar:
		\url{https://upload.wikimedia.org/wikipedia/commons/4/43/While-loop-diagram.svg} }

		Anatomien af en \JavaInline{while}-udstryk er meget lig det af et
		\JavaInline{if}-udstryk, du skifter bare \JavaInline{if} ud med
		\JavaInline{while}, som kan ses i eksempel~\ref{lst:while-example-1}.

		\begin{JavaCode}{``Fej Gulvet'' pseudo-Java.}{lst:while-example-1}
			while (gulvet er beskidt) {
				fej gulvet;
			}
		\end{JavaCode}

		Man kalder koden mellem paranteserne for while-udtrykkets ``betingelse'',
		koden mellem tuborg-klammerne for ``kroppen'' af
		\JavaInline{while}-udtrykket, og man kalder hver gennemgang af kroppen
		for en ``iteration''.

		Nu kan man spørge: ``Hvis jeg kan lave et program som aldrig stopper, en
		såkaldt uendelig løkke?'' Ja, det er faktisk ret nemt. Så nemt at mange
		kommer til at lave en uønsket uendelig løkke, nu og da. Se
		eksempel~\ref{lst:while-hello-world}
		for et program som gentagende skriver ``hej''. Det er selvfølgelig ikke
		så brugbart et program, men det viser en problematik: Hvad gør vi hvis
		vores program aldrig stopper? \todo{Svar på ``Hvad gør vi hvis
		vores program aldrig stopper?''} \footnote{Dette stiller selvfølgelig spørgsmålet ``kan man lave et program som kan sige om et program stopper eller ej?''. Det er muligt at lave et program, som svarer for \emph{nogle} programmer, men umuligt at lave en som kan svare for \emph{alle} programmer. Denne problematik kaldes for \emph{The Halting Problem}, og blev bevist af \emph{Allan Turing}.}

		\begin{JavaCode}{Et program der aldrig ender}{lst:while-hello-world}
			System.out.println("Hello World!");
			while (true) {
				System.out.println("Hello again!");
			}
		\end{JavaCode}

		 Oftests vil man bruge
		en betingelse som kan variere mellem iterationerne. I
		eksempel~\ref{lst:while-example-3} kan ses hvordan man kan tælle op fra
		1 til 10.

		\begin{JavaCode}{Et ``brugbart'' while program}{lst:while-example-3}
			int n = 1;
			while (n <= 10) {
				System.out.println(n + " linjer af ligegyldig data.");
				n++;
			}
		\end{JavaCode}

		\begin{exercise}
			Copenhagen Suborbitals har kontaktet dig, for at lave en maskine til
			at tæller ned fra 10, og vise "Affyring!", i stedet for 0.
		\end{exercise}

		\begin{exercise}
			Skriv et program som tæller op fra \(1\) til \(100\), og for hvert
			tal, printer tallet, og printer ``foo'' hvis det kan divideres med 3,
			og ``bar'' hvis det kan divideres med 5. Hvis det kan divideres med
			både 3 og 5, print ``foobar''.
		\end{exercise}

	\subsection{For-løkker}

		I sidste sektion så vi kan tælle op med et \JavaInline{while}-udtryk.
		Dette er da ikke en idéel måde at tælle på, da \JavaInline{n}
		defineres, sammenlignes og opdateres på helt forskellige steder i koden.
		Det kan blive svært at holde styr på i store programmer, hvilket er
		hvorfor Java har \JavaInline{for}-løkken, som samler den information i
		èt sted: \JavaInline{for (before_loop; condition_of_loop; after_every_iteration)}

		\todo{ Uddyb og udfyl. }

		Strukturen af for-løkker er ret involveret, men det hjælper at
		sammenligne med \JavaInline{while}-udstryk, og se hvordan at forskellige
		dele af koden som tidligere var sprædt, nu er samlet.

		\begin{JavaCode}{Et ``brugbart'' for program. Sammenlign med eksempel~\ref{while-example-3}.}{lst:for-example-1}
			for (int n = 1; n <= 10; n++) {
				System.out.println(n + " linjer af ligegyldig data.");
			}
		\end{JavaCode}

		\begin{exercise}
			Det er ofte fortalt hvordan at Gauss i sine unge dage, forpurrerede sin
			lærers plan om at få ham til at tie stille. Hun bedte ham lægge tallene
			fra \(1\) til \(100\) sammen, i håbet at dette ville optage det unge
			geni i lidt tid. Gauss realiserede dog at der måtte være en bedre måde
			at løse problemet på, og udledte formularen \(\frac{n\cdot(n+1)}{2}\).
			Han svarede hurtigt \(5050\), og så måtte læreren finde på en anden
			kedelig opgave.

			Brug et \emph{for-loop} til at beregne \(1^2+2^2+\dots+100^2\).
		\end{exercise}

		\begin{exercise}
			Der er selvfølgelig ikke noget som forhindrer at du bruger et
			\emph{for-loop} ind i et andet \emph{for-loop}, og dette kan nogle gang
			være vældig praktisk.

			\todo{Find på opgave!}
		\end{exercise}

	\subsection{Break-udtryk}

		\todo{Udvid sektion}

		Sommetider vil man gerne gå ud af en løkke tidligt. Dette tillader
		\JavaInline{break}-keywordet os at gøre.

		\begin{JavaCode}{Et brugbart while program som stopper efter 10 linjer, på trods af et uendeligt loop.}{lst:break-example-1}
			int n = 1;
			while (true) {
				System.out.println(n + " linjer af ligegyldig data.");
				n++;
				if (n == 10)  break;
			}
		\end{JavaCode}


		\todo{
			Som perspektiverende bonus kunne jeg tænke mig at fortælle lidt af
			historien om \emph{structured programming}, og hvorfor \JavaInline{goto}
			ikke er en ting i Java. \emph{Ikke pensum, bare for sjov.}
		}

	\subsection{!EXTRA! Do ... while}

		\todo{Udvid sektion}

		While-løkker tjekker om den burde fortsætte før iterationerne, men nogle
		gang vil vi gerne tjekke om vi fortsætter, efter vi har kørt
		iterationen. For eksempel kunne vi lave en beregning, og baseret på den
		beslutte om vi ville videre. Dette løser \emph{do-while} udtryk på en
		pæn måde.

		\begin{JavaCode}{Vil aldrig skrive ``Hej med dig''.}{lst:unknown-bc}
			while (false) {
				System.out.println("Hej med dig");
			}
		\end{JavaCode}

		\begin{JavaCode}{Vil skrive ``Hej med dig'' en enkelt gang.}{lst:unknown-b}
			do {
				System.out.println("Hej med dig");
			} while (false)
		\end{JavaCode}

		For eksempel:

		\begin{JavaCode}{Todo}{lst:unknown-c}
			String a = "";
			do {
				a = " " + a.length();
			} while (a.length <= 10);
			System.out.println(a);
		\end{JavaCode}

		\todo{Giv historien om at while-løkker var for dyre i forhold til do-while.}

	\subsection{Continue}

		I visse situationer giver det mening at hoppe over en iteration af en
		løkke. Dette kan gøres ved brug af \JavaInline{continue}-keyworded.

		\begin{JavaCode}{Kode der anvender \emph{continue} til at kun vise de lige tal.}{lst:unknown-a}
			for (int i = 1; i <= 10; i++) {
				if (i % 2 == 0)  continue;
				System.out.println(i);
			}
		\end{JavaCode}

		\todo{Skriv mere?}

		\todo{Lav opgave}

\section{Funktioner}

	Sidste kapitel introducerede \emph{funktioner}\footnote{Også kaldet \emph{metoder} eller \emph{procedurer}.}
	som sorte-bokse, der gør arbejde for dig. For eksempel \JavaInline{Math.abs}
	som giver den absolutte værdi af hvadend den bliver givet. I denne sektion
	beskrives hvordan man definerer sine egne funktioner, en færdighed som viser
	sig at være meget brugbar, da funktioner kan gentage arbejde på en
	anderledes måde end løkker kan.

	Vi kalder hvad en funktion giver tilbage for dens \emph{retur-værdi} eller
	hvad funktionen \emph{returnerer}. Vi kalder hvad vi giver den, dvs. det som
	sættes mellem paranteser, for funktionens \emph{argumenter}.

	\todo{
		Denne sektion vil dække \emph{metode-definitioner}, \emph{retur-typer},
		\emph{argument-lister} og \JavaInline{return}.
		Jeg vil ikke dække statiske metoder, overloading, eller andre advanceret
		emner, da disse igen er ret niché, og kræver introduktion til nye
		koncepter.
	}

	\todo{
		\emph{pass-by-value} vs. \emph{pass-by-reference} bør nok dækkes, da det
		garenteret vil dukke op. Det er bare ikke specielt relevant før de kender
		til objekter. Antager ikke de vil rende ind i problemet før under projektet.
		Jeg er ikke vild med at introducere dem til sådanne niché fagtermer, men
		det vil være nemmere for en hjælper at kunne sige ``læs dette stykke om
		hvorfor dit program ikke fungere korrekt.''
	}

\iffalse% havde glemt at funktioner allerede var defineret tidligere, og behøver derfor ikke en motivation.

	For eksempel: Hvis vi har skrevet noget kode som beregner faktorialet af
	\(10\), som vi har gjort i listing~\ref{lst:factorial-of-10}. Men hvis vi
	også gerne ville beregne faktorialet af \(20\) skulle vi kopiere koden og
	ærstatte \(10\) med \(20\). Alternativt kunne vi lave en funktion, som
	beregner faktorialet for et hvilkårligt tal, og giver os svaret.

	\begin{JavaCode}{Kode som beregner faktorialet af \(10\) og viser det.}{lst:factorial-of-10}
		int a = 1;
		for (int i = 1; i <= 10; i++)
			a = a * i;
		System.out.println(a);
	\end{JavaCode}

	\todo{Snak om Java-filer og deres forhold til funktioner.}

	\begin{JavaCode}{Java-fil med fakultet funktion og main}{lst:factorial-with-main}
	class Factorial {

		public int factorial (int n) {
			int a = 1;
			for (int i = 1; i <= n; i++)
				a = a * i;
			return a;
		}

		public static void main(String[] args) {
			int fac_of_10 = factorial(10);
			int fac_of_20 = factorial(20);
		}

	}
	\end{JavaCode}

\fi

	\subsection{En funktions udseene}

		I har allerede set en funktion, nemlig \JavaInline{main}-funktionen, hvor i
		indtil videre har skrevet alle jeres programmer i:

		\begin{JavaCode}{Main funktion}{lst:main-function}
			public static void main(String[] args) {
				// Ting her...
			}
		\end{JavaCode}

		En funktion består af dens \emph{signatur} og dens \emph{krop}.

		Dens signatur er \JavaInline{public static void main(String[] args)} delen.
		Dette fortælles os lidt om funktionen: dens navn \emph{main}; dens
		retur-værdi, \emph{void}, hvilket står for ingenting; og dens argumenter,
		\emph{String[] args}, en liste af strenge, som funktionen kalder \emph{args}.
		Signaturen for \emph{main} siger også at den er \emph{static} og
		\emph{public}. Disse egenskaber kan i ignorere for nu, da de først bliver
		relevant i næste kapitel.

		En funktions krop er \JavaInline{// Ting her...} delen. Alt mellem
		krølleparanteserne er funktionens krop, og beskriver hvad funktionen gør.
		Hvis funktionen har en retur-værdi, skal \JavaInline{return}-keywordet opstå
		mindst én gang i kroppen. Det er denne som stopper funktionen, og returnerer.

		Du kan se det som at signaturen er hvordan vi snakker med funktionen, men
		dens krop er hvad den gør.

		Hvis vi skulle skrive \emph{faktoriel}-funktionen som en funktion i Java,
		ville vi først spørge os selv: ``hvad returnerer faktoriel og hvad er dens
		argumenter?'' Det virker måske trivielt, i dette eksempel, men stadig et
		vigtigt spørgsmål. Derefter skal vi spørge: ``Men hvad er det den gør?''

		Faktoriellen er defineret som \(a! = a \cdot (a-1) \cdot \dots \cdot 2 \cdot 1\),
		f.eks. \(5! = 5 \cdot 4 \cdot 3 \cdot 2 \cdot 1\). Ud fra definitionen er det
		tydeligt at den får et enkelt heltal, og giver et enkelt heltal tilbage. Så
		faktoriellens signatur ser sådan ud:

		\begin{JavaCode}{Signaturen af en faktoriel-funktion}{lst:factorial-signature}
			int factorial (int a)
		\end{JavaCode}

		Men hvad gør faktoriel funktionen? Den ganger det givne heltal med alle mindre
		heltal. Vi behøver at finde alle mindre heltal og gange det på. En version
		af faktorial-kroppen kunne ligne:

		\begin{JavaCode}{Kroppen af en faktoriel-funktion}{lst:factorial-body}
			int product = 1;
			for (int i = a; i >= 1; i--)
				product *= i;
			return product;
		\end{JavaCode}

		Kombinationen af signaturen og kroppen resulterer i:

		\begin{JavaCode}{En faktoriel-funktion}{lst:factorial-function}
			int factorial (int a) {
				int product = 1;
				for (int i = a; i >= 1; i--)
					product *= i;
				return product;
			}
		\end{JavaCode}

		Det er vigtigt at notere at kroppen kunne have set meget anderledes ud, da
		der er utallige ækvivalte kroppe, men hvordan kroppen ser ud er ligegyldigt for
		hvadend der anvender funktionen, så længe signaturen stadig passer.

		\todo{Skriv mere på denne undersektion}

		\todo{Er det mig som skal forklare \emph{private} og \emph{public}? Det er næste mere relevant i klasser kapitlet.}

	\subsection{Procedurer: Eller funktioner som ikke returnerer noget}

		\todo{
			Skriv denne undersektion.
			Spørgsmål at svare på:

			(1.) Hvorfor er void funktioner interessante? Nok best at demonstrere
			ved brug af print. Har de lært om class variabler? Så er de også gode
			kandidater.
			(2.) Hvordan ser void functioner ud?
		}

	\subsection{Standard Bibliotek}

		\todo{Find interessant info til denne sektion}

	\subsection{!Extra! Rekursion}

	\todo{Dette kaldes rekursion, og det minder lidt om induktion, som i nok kender til

	-- Kurt til Datalogi-russerne, under deres først forelæsning.}

	\todo{
		Kort forklaring om hvad rekursion er. Regner ikke med at de forstår det.
		Stadig brugbart at dække kort. Meget vigtigt at det er så nede til
		jorden som muligt. Faktorial-funktionen er idéel.
	}


	\begin{JavaCode}{Rekursiv Fakultet}{lst:factorial-recursive}
		public int factorial (int n) {
			if (n <= 1)  return 1;
			return n * factorial(n-1);
		}
	\end{JavaCode}

	\begin{JavaCode}{Akkumulator Fakultet}{lst:factorial-accumulator}
		public int factorial (int n, int a) {
			if (n <= 1)  return a;
			return factorial(n-1, n * a);
		}
	\end{JavaCode}

	\begin{JavaCode}{Fakultet funktionen hvis Java var godt}{lst:factorial-good}
		fun factorial 0  =  1
		  | factorial n  =  n * factorial (n - 1)
	\end{JavaCode}

	\begin{exercise}
		Lige tal er de tal der kan deles med \(2\), dvs. \(0, 2, 4, \dots\).
		Ulige tal er så alle de andre heltal. Disse to mængder kan også defineres
		rekursivt.

		Vi ved at et tal er lige, hvis det forrige tal var ulige. Så hvis vi ved
		at \(5\) er ulige, så ved vi at \(6\) er lige. Ulige tal er omvendt, vi
		ved at \(5\) er ulige, hvis vi ved at \(4\) er lige.

		Men vi er nødt til at stoppe på et tidspunkt. Derfor definerer vi
		\(0\) til at være lige.

		Lav to funktioner \JavaInline{odd} og \JavaInline{even}, som modellere
		denne process ved at kalde hinanden. Begge bør tage et heltal, og give
		tilbage en boolesk værdi.

		\todo{
			Jeg er ikke helt tilfreds med denne opgave. (mutual) Rekursion er
			måske lidt for advanceret. Desuden tvivler jeg på at forholdet
			mellem lige og ulige tal forklares ordentligt. Syntes hellerer ikke
			at der lægges godt nok op til hvad de skal gøre.
		}

	\end{exercise}

	\todo{
		Vil gerne have en opgave som direkte takler hvordan funktioner og løkker
		er forskellige.

		``Kan jeg ikke bare gøre det med en for-løkke?''
	}

\section{Arrays}

	\todo{Denne sektion er omkring Arrays. Skriv den!}

	\todo{
		Lister er en fundamentel datastruktur, sandeligt er datamaten selv en
		kæmpe liste af data.
		Denne sektion vil dække arrays, f.eks. \JavaInline{int[]}.
		Kræver introduktion til arrays og subscripts.
	}

	\begin{exercise}
		Lav en funktion, som givet en liste af tal, finder det største tal i den
		liste.
	\end{exercise}

	\begin{exercise}
		\todo{Forbedre første sætning.}
		Et heltal \(n\) er et primtal, hvis det kun er \(1\) og \(n\) selv som
		deler \(n\). Disse tal var originalt en tal-teoretisk kuriositet, men
		anvendes nu til dags i kryptografien, hvor det er vigtigt at finde store
		primtal.

		En klassisk \emph{algoritme} til at finde primtal, kaldet
		\emph{Eratosthenes' si}, involverer at have en liste af heltal fra \(1\)
		til \(n\), hvor man starter med at fjerner alle multiplum af
		\(2, 3, 4, \dots, n\). Hvad man ender med til slut er en liste af primtal.

		Implementer \emph{Eratosthenes' si} op til \(100\) ved brug af et
		array, og to for-løkker. Bare sæt ikke-primtal til \(0\).
	\end{exercise}

\section{!Extra! Checked Exceptions}

	Nogle funktioner kan fejle, for eksempel hvis den gør ting over internettet.
	Men hvad skal Java gør hvis programmet fejler? Programmøren vil ofte gerne
	vide at der er en fejl, sådan at de kan fikse den. En mulighed er at give en
	unik retur-værdi, men dette er ikke altid muligt, alternativt kan man bare
	dræbe programmet, og give en sur fejl til programmøren, hvilket er simpelt,
	men ikke robust. Java har en helt tredje mulighed, den kan fange fejlene i
	en såkaldt ``try-catch'' kontrol-struktur:

	\begin{JavaCode}{Eh?}{lst:try-catch-example}
		try {
			// Ting her...
		} catch (<exception-type> e) {
			// Fiks fejlen
		}
	\end{JavaCode}

	Dette tillader os at ``fange'' fejl der opstår i \JavaInline{// Ting her...}
	delen, og gøre ting for at fikse fejlen i \JavaInline{// Fiks fejlen}.

	Denne kontrol-struktur er heldigvis ikke noget man normal behøver at bekymre
	sig om. Men Java er smart, og kan se når der er en mulighed for at opstå
	fejl, hvilket den vil klage over når du kompilerer dit program, ikke når du
	kører dit program. Dette kaldes \emph{checked exceptions}, og betyder at du
	sommetider er nødt til at lave en try-catch.

	\todo{Hej med dig, du er exceptions.}

	Nogle funktioner i standard bibloteket anvender en funktionalitet kaldet
	.
