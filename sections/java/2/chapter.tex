
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Kontrol og Metoder}

	I sidste kapitel blev variabler, aritmetiske udtryk og \emph{if-statements}
	introduceret. Med disse dele kan man lave det der heder et
	\emph{straight-line program}. Men vi er ofte stillede over for problemer som
	ikke kan løses ekslusivt med sådanne programmer. Vi behøver mere
	udtrykskraft, end hvad aritmetik og basal beslutningsevner kan give os.
	For eksempel vil vi gerne kunne sige ting som ``gør \emph{det her} indtil
	\emph{dette} sker'' eller ``gør \emph{dette}, først for \emph{1}, og så for
	\emph{2}, osv.''

	Af denne grund indeholder mange programmerings-sprog, inklusiv Java,
	mekanismer for at kunne udtrykke sådanne problemer, og det er disse
	mekanismer vi vil dække i dette kapitel.

	Emner i dette kapitel:

	\begin{itemize} % Denne udgiver har også følgende selvhjælps-bøger på markedet:
		\item Løkker: Sådan får du mere kontrol
		\item Funktioner: Forbedre dine metoder
		\item Algoritmer: Find din indre effektivitet
	\end{itemize}

\section{Løkker}

	\subsection{While-løkker}

		\JavaInline{while} er den simpleste af løkkerne. Dette er ligesom at
		sige: ``Mens at A gælder, sørg for at gøre B.'' For eksempel:
		``Mens at gulvet er beskidt, bør du feje gulvet.''

		Dette er i modsætning til \JavaInline{if}-udstryk, hvor der udtrykkes
		``Hvis A gælder, gør B èn enkelt gang.''

		\todo{ Skal fyldes mere på. Sektion: \JavaInline{while} }

		\todo{ En illustration som denne kunne være brugbar:
		\url{https://upload.wikimedia.org/wikipedia/commons/4/43/While-loop-diagram.svg} }

		Anatomien af en \JavaInline{while}-udstryk er meget lig det af et
		\JavaInline{if}-udstryk, du skifter bare \JavaInline{if} ud med
		\JavaInline{while}, som kan ses i eksempel~\ref{lst:while-example-1}.

		\begin{JavaCode}{``Fej Gulvet'' pseudo-Java.}{lst:while-example-1}
			while (gulvet er beskidt) {
				fej gulvet;
			}
		\end{JavaCode}

		Man kalder koden mellem paranteserne for while-udtrykkets ``betingelse'',
		koden mellem tuborg-klammerne for ``kroppen'' af
		\JavaInline{while}-udtrykket, og man kalder hver gennemgang af kroppen
		for en ``iteration''.

		Nu kan man spørge: ``Hvis jeg kan lave et program som aldrig stopper, en
		såkaldt uendelig løkke?'' Ja, det er faktisk ret nemt. Så nemt at mange
		kommer til at lave en ueønsket uendelig løkke, nu og da. Se
		eksempel~\ref{lst:while-hello-world}
		for et program som gentagende skriver ``hej''. Det er selvfølgelig ikke
		så brugbart et program, men det viser en problematik: Hvad gør vi hvis
		vores program aldrig stopper? \todo{Svar på ``Hvad gør vi hvis
		vores program aldrig stopper?''} \footnote{Dette stiller selvfølgelig spørgsmålet ``kan man lave et program som kan sige om et program stopper eller ej?''. Det er muligt at lave et program, som svarer for \emph{nogle} programmer, men umuligt at lave en som kan svare for \emph{alle} programmer. Denne problematik kaldes for \emph{The Halting Problem}, og blev bevist af \emph{Allan Turing}.}

		\begin{JavaCode}{Et program der aldrig ender}{lst:while-hello-world}
			System.out.println("Hello World!");
			while (true) {
				System.out.println("Hello again!");
			}
		\end{JavaCode}

		 Oftests vil man bruge
		en betingelse som kan variere mellem iterationerne. I
		eksempel~\ref{lst:while-example-3} kan ses hvordan man kan tælle op fra
		1 til 10.

		\begin{JavaCode}{Et ``brugbart'' while program}{lst:while-example-3}
			int n = 1;
			while (n <= 10) {
				System.out.println(n + " linjer af ligegyldig data.");
				n++;
			}
		\end{JavaCode}



	\subsection{For-løkker}

		I sidste sektion så vi kan tælle op med et \JavaInline{while}-udtryk.
		Dette er da ikke en idéel måde at tælle på, da \JavaInline{n}
		defineres, sammenlignes og opdateres på helt forskellige steder i koden.
		Det kan blive svært at holde styr på i store programmer, hvilket er
		hvorfor Java har \JavaInline{for}-løkken, som samler den information i
		èt sted: \JavaInline{for (before_loop; condition_of_loop; after_every_iteration)}

		\todo{ Uddyb og udfyl. Sektion: \JavaInline{for} }


		For strukturen af for-løkker er ret involveret, men det hjælper at
		sammenligne med \JavaInline{while}-udstryk, og se hvordan at forskellige
		dele af koden som tidligere var sprædt, nu er samlet.

		\begin{JavaCode}{Et ``brugbart'' for program. Sammenlign med eksempel~\ref{while-example-3}.}{lst:for-example-1}
			for (int n = 1; n <= 10; n++) {
				System.out.println(n + " linjer af ligegyldig data.");
			}
		\end{JavaCode}

		\begin{exercise}
			Det er ofte fortalt hvordan at Gauss i sine unge dage, forpurrerede sin
			lærers plan om at få ham til at tie stille. Hun bedte ham lægge tallene
			fra \(1\) til \(100\) sammen, i håbet at dette ville optage det unge
			geni i lidt tid. Gauss realiserede dog at der måtte være en bedre måde
			at løse problemet på, og udledte formularen \(\frac{n\cdot(n+1)}{2}\).
			Han svarede hurtigt \(5050\), og så måtte læreren finde på en anden
			kedelig opgave.

			Brug et \emph{for-loop} til at beregne \(1^2+2^2+\dots+100^2\).
		\end{exercise}

		\begin{exercise}
			Der er selvfølgelig ikke noget som forhindrer at du bruger et
			\emph{for-loop} ind i et andet \emph{for-loop}, og dette kan nogle gang
			være vældig praktisk.

			TODO: Find på opgave!
		\end{exercise}

	\subsection{Break-udtryk}

		\todo{ Sektion: \JavaInline{break} }

		\todo{
			Som bonus vil jeg gerne have noter om \JavaInline{do ... while} og
			\JavaInline{continue}, da disse er niché, men er samtidige nemme at
			forstå.

			Jeg vil ikke have noter om mere niché ting, som f.eks
			\emph{named-breaks}, da disse kræver introduktion til nye koncepter.
		}

		\todo{
			Som perspektiverende bonus kunne jeg tænke mig at fortælle lidt af
			historien om \emph{structured programming}, og hvorfor \JavaInline{goto}
			ikke er en ting i Java. \emph{Ikke pensum, bare for sjov.}
		}

\blindtext

\section{Funktioner}

	\todo{
		Denne sektion vil dække \emph{metode-definitioner}, \emph{retur-typer},
		\emph{argument-lister} og \JavaInline{return}.
		Jeg vil ikke dække statiske metoder, overloading, eller andre advanceret
		emner, da disse igen er ret niché, og kræver introduktion til nye
		koncepter.
	}

	\todo{
		\emph{pass-by-value} vs. \emph{pass-by-reference} bør nok dækkes, da det
		garenteret vil dukke op. Det er bare ikke specielt relevant før de kender
		til objekter. Antager ikke de vil rende ind i problemet før under projektet.
		Jeg er ikke vild med at introducere dem til sådanne niché fagtermer, men
		det vil være nemmere for en hjælper at kunne sige ``læs dette stykke om
		hvorfor dit program ikke fungere korrekt.''
	}

\blindtext

\section{Algoritmer eller Lister}

	\todo{
		Jeg kan ikke helt beslutte mig, hvad denne sidste sektion skal være om; enten
		kort om algoritmer; eller røre lidt ved lister.
		Understående giver pitches for begge.
	}

	\todo{
		Denne forlæsning og sektion dækker kort hvad Fanden en algoritme er, og
		giver simple eksempler, som viser hvordan man kan anvende dette kapitels
		tidligere emner.
		Et klart eksempel er fakultet-funktionen (eller muligvis fibonnaci,)
		da denne både kan udtrykkes med en for-lykke, rekursivt, og endda
		tail-rekursivt med en akkumulator! (Denne sidste er klart for
		advanceret, men min indre Olivier kan ikke lade vær.)
	}

	\todo{
		Lister er en fundamentel datastruktur, sandeligt er datamaten selv en
		kæmpe liste af data.
		Denne sektion vil dække \JavaInline{ArrayList} eller måske bare
		\JavaInline{int[]}? Jeg ved det ikke. Den første kræver introduktion til
		objekter, og den anden kræver introduktion til arrays og subscripts.
		Ingen af dem er elegante eller simple.
	}

	\todo{Note til Lukas: Kan vi bruge en mono-spaced font til kode, både
	inline og til blokke? Den nuværende er hæslig til begge dele. Er meget tilfreds med lstautogobble!}

	\begin{JavaCode}{Iterativ Fakultet}{lst:factorial-iterative}
		public int factorial (int n) {
			int a = 1;
			for (int i = 1; i <= n; i++)
				a = a * i;
			return a;
		}
	\end{JavaCode}

	\begin{JavaCode}{Rekursiv Fakultet}{lst:factorial-recursive}
		public int factorial (int n) {
			if (n <= 1)  return 1;
			return n * factorial(n-1);
		}
	\end{JavaCode}

	\begin{JavaCode}{Akkumulator Fakultet}{lst:factorial-accumulator}
		public int factorial (int n, int a) {
			if (n <= 1)  return a;
			return factorial(n-1, n * a);
		}
	\end{JavaCode}

	\begin{JavaCode}{Fakultet funktionen hvis Java var godt}{lst:factorial-good}
		fun factorial 0  =  1
		  | factorial n  =  n * factorial (n - 1)
	\end{JavaCode}

\blindtext
