\chapter{Objekter og klasser}

I kernen af objekt-orienteret programmering er de to nøglebegreber; objekter og klasser. Når man skriver i et objektorienteret sprog, vil de objekter, man opretter, vises i problemdomænet og udgør de dele af modellen, som dit computerprogram forsøger at emulere. Objekter kategoriseres af klasser. En klasse beskriver alle objekter af en bestemt type. Dette kan virke lidt abstrakt, så lad os forsøge at forstå dette ved hjælp af et eksempel på at simulere en boghandel.

\begin{example}
	Hvis vi ønsker at skrive et computerprogram, der er en simpel simulation af en boghandel, skal vi arbejde med et par forskellige enheder, hvoraf en kunne være bøger. Er en bog en klasse eller et objekt? Hvad er genren? Hvem er forfatteren? Hvornår blev det skrevet? Hvad er titlen?
	
	Alle ovenstående spørgsmål giver kun mening i forbindelse med en enkelt bog. Dette skyldes, at "bog" i denne sammenhæng refererer til klassen Bog, mens en enkelt bog er et objekt af denne klasse. En enkelt genstand henvises til som et eksempel. Du kan oprette flere forekomster af en klasse, som i ovenstående eksempel vil give os mulighed for at lave mange forskellige bøger i mange forskellige genrer med forskellige titler, forfattere og publikationsdatoer.
\end{example}

\section{Klasser}
Når vi skal lave en ny klasse i java, gør vi det typisk i en ny fil. Vi skal kalde filen det, vi gerne vil kalde klassen, så hvis vi gerne vil oprette en klasse \JavaInline|Book| så starter vi med at lave en ny fil Book.java.

Et eksempel på en deklaration af en klasse ses i \autoref{lst:book-class-header}

\begin{JavaCode}{Book klasse deklaration}{lst:book-class-header}
	public class Book {
		// This is the class body
	}
\end{JavaCode}

Klasse deklarationen består essentielt af 3 ting, først en access modifier (\JavaInline|public|), der definerer hvorfra man kan få adgang til klassen, derefter ordet \JavaInline|class|, der definerer, at det er en klasse vi laver, sidst har vi navnet på vores klasse (\JavaInline|Book|). Bemærk at klassenavnet er stavet med stort forbogstav. Mellem de to tuborgklammer i klassens krop, det er der vi definerer, hvad klassen rent faktisk kan bidrage med.

\subsection{Access modifiers}

I har set flere eksempler på brug af access modifiers allerede, både når vi definerer nye klasser, men også når vi definerer metoder. Access modifiers definerer hvorfra i vores kode, vi vil kunne få fat i vores klasser og metoder. Der er 4 forskellige acces modifiers:

\subsubsection{Private}

i klasse

\subsubsection{public} 

over alt

\subsubsection{protected} 

i pakke, gennem nedarvning udenfor pakken, kun på metoder, constructor og variable

\subsubsection{default} 

i pakke

\subsection{Fields}
En klasse kan have en række variable, der kan holde information, om hvilket state klassen er i lige nu, men også til at holde al den information, der er fælles for alle instanser af den givne klasse, men hvis værdi vil variere fra instans til instans disse betegnes fields. Når vi kigger på en bog, så har den en titel, en forfatter, en genre, måske et årstal, alle bøger har dette, men det vil ikke være det samme for hver bog, vi kan derfor have det som fields i vores bog klasse, se \autoref{lst:book-class-variables}

\begin{JavaCode}{Book klasse fields}{lst:book-class-variables}
	public class Book {
		//fields
		private String title;
		private String author;
		private String genre;
		private int publishYear;
		
		//rest of class body
	}
\end{JavaCode}

Læg mærke til at variablerne er private, dette er af hensyn til, at de så ikke kan ændres udefra, men kun er tilgængelige for de metoder, der ligger inde i klassen.

\subsection{Constructor}

En constructor er en særlig metode, der bliver kaldt når man opretter et objekt af den givne klasse. Det er her, vi gerne instantierer alle variable, vi skal bruge i den givne klasse, og generelt sætter klassen op, så den er klar til brug. Constructoren varierer fra andre metoder, i at metodenavnet skal være det samme som klassenavnet, ellers fungerer det ligesom andre metoder, der kan have nogle parametre. En constructor kan dog aldrig returnere noget. Et eksempel på en constructor kan ses i \autoref{lst:book-class-constructor}

\begin{JavaCode}{Book klasse constructor}{lst:book-class-constructor}
	public class Book {
		//fields
		private String title;
		private int publishYear;
		
		//constructor
		public book(String title, int publishedIn) {
			this.title = title;
			publishYear = publishedIn;
		}
		
		//rest of class body
	}
\end{JavaCode}

Constructoren tager imod nogle parametre, vi gemmer i vores fields, på den måde er vores bog initialiseret med en titel og udgivelsesår, hvilket vi kan benytt,e når vi senere hen skal til at lave andre metoder i klassen. Bemærk at der står \JavaInline|this.title| for at referere til title field, dette skyldes at vi fortæller constructoren, at vi vil assigne værdien af parametrer title til field'et title, hvis vi ikke skrev \JavaInline|this.| ,så ville den assigne værdien til sig selv, og vores field ville stadig være tomt. Det er derfor ikke nødvendigt at skrive \JavaInline|this.| foran \JavaInline|publishYear|, da der ikke er noget sammenfald i navgivningen og der ikke kan være tvivl om, hvad der menes, det er dog helt i orden at gøre alligevel.

\subsection{Metoder}

Metoder virker på samme måde som vi allerede har set, der er dog to standard metoder, man ofte ser i klasser, nemlig \JavaInline|get| og \JavaInline|set| metoder, disse gør det fx muligt, at få adgang til, at se eller ændre fields. 

Hvis vi gerne vil kunne se, hvad der ligger i de forskellige fields uden for vores klasse, skal vi tilføje metoder, der er public, som kan hive det ud, disse kaldes \JavaInline|get| metoder, da det henter information. I \autoref{lst:book-class-get}

\begin{JavaCode}{Book klasse get metode}{lst:book-class-get}
	public String getTitle() {
		return title;
	}
\end{JavaCode}

\JavaInline|get| metoder returnerer altid noget, og i sin rene form navngives den \JavaInline|get<<fieldname>>| og returner \JavaInline|<<field>>|.

Hvis det skal være muligt at ændre værdien i sine fields, kan dette gøres med \JavaInline|Set| metoder, et eksempel på at sætte prisen på en bog kan ses i \autoref{lst:book-class-set}

\begin{JavaCode}{Book klasse set metode}{lst:book-class-set}
	public void setPrice(double price) {
		this.price = price;
	}
\end{JavaCode}

\JavaInline|set| metoder vil i sin rene form aldrig returnerer noget, men have en parameter, der erstatter værdien af \JavaInline|<<field>>| og hedde \JavaInline|set<<field>>|

Vi ender dermed med den fulde klassedefinition, der kan ses i \autoref{lst:book-class}

\begin{JavaCode}{Book klasse}{lst:book-class}
	public class Book {
		//fields
		private String title;
		private int publishYear;
		private double price;
		
		//constructor
		public book(String title, int publishedIn) {
			this.title = title;
			publishYear = publishedIn;
			price = 0.0;
		}
	
		//get methods
		public String getTitle() {
			return title;
		}
		public String getPublishYear() {
			return publishYear;
		}
		public String getPrice() {
			return price;
		}
		
		//set methods
		public void setPrice(double price) {
			this.price = price;
		}
	}
\end{JavaCode}

I dette eksempel er det muligt at ændre prisen, og det er ikke nødvendigt at kende prisen for at lave en bog, vi initialiserer dog prisen til 0, når vi laver bogen, så er vi sikker på at vi har initialiseret alle vores fields. Der er get metoder til alle fields, så det er muligt at spørge klassen, om hvad titlen, udgivelsesåret og prisen er på bogen. Der er kun oprettet set metode til prisen, da det ikke giver mening at kunne ændre titel og udgivelsesår efter en bog er udgivet, hvis disse skulle ændres, ser vi det som en ny bog.

\subsection{Nedarvning}

Nedarvning er en central del af Java. Alle klasser vi selv skriver nedarver fra \JavaInline|Objekt| klassen. Dette er ikke noget vi mærker så meget til, men det giver os noget indbygget funktionalitet som vi ofte gør brug af, som fx \JavaInline|toString()|. Brugen af nedarvning giver os muligheden for at undgå kode duplikation, dette gøres ved at lave klasser der kan være en udvidelse af en anden, på denne måde bruge koden i en anden klasse i en udvidet klasse. For eksempel kan du have to klasser, en der er kaldet \JavaInline|Car| og en anden kaldet \JavaInline|Bicycle|. Her kan vi bruge nedarvning til at lave en ny klasse kaldet \JavaInline|Vehicles|. Denne vil så indeholde de ting som både \JavaInline|Bicycle| og \JavaInline|Car| indeholder, på denne måde kan \JavaInline|Car| og \JavaInline|Bicycle| så indeholde de ting der gør dem unikke. Hvormed kode duplikation kan undgås.

Kode duplikation er en term der bruges til at omtale hvis sektioner af kode bliver gentaget i et udviklet program. Sådanne tilfælde er generelt uønsket og dårligt design, da det gør det sværere at arbejde videre med programmet eller fikse forskellige bugs opstået fra kode der er duplikeret, da ændringen så skal laves alle steder koden er duplikeret og derved skal programmøren finde alle tilfælde af kode duplikationen for at fikse en bug. Kode duplikation øger derved risikoen for at bugs måske kun bliver løst halvt, dette kunne for eksempel ske hvis man havde forskellige NPCs i et computerspil og så havde kopieret angrebsfunktionen ind i den enkelte NPC, hvis denne funktion var buggy skulle man så finde den alle steder, og kunne nemt komme til at glemme det i nogle af dem. Så selvom det virker nemmere og mere simpelt at kopiere et stykke kode, så burde man designe sig ud af at have kode duplikation, da du ellers, med al sandsynlighed, skal arbejde ekstra meget senere hen for at have det nemt nu.

Den følgende tekst vil sætte dig ind i nedarvning i Java og hvordan dette gøres. I \autoref{lst:inheritance-vehicle} kan du se \JavaInline|Vehicle| klassen.

\begin{JavaCode}{Vehicle klassen}{lst:inheritance-vehicle}
	public class Vehicle
	{
		private String Owner;
		private int NumberOfWheels;
		//...
	}
\end{JavaCode}
	
I \autoref{lst:inheritance-car} kan du se \JavaInline|Car| klassen.

\begin{JavaCode}{Car klassen}{lst:inheritance-car}
	public class Car extends Vehicles
	{
		private String NumberPlate;
		//...
	}
\end{JavaCode}

I Car klassen kan termen \JavaInline|extends| ses, dette er for at klargøre nedarvning forholdet for de to klasser. Hvilket her specificerer at \JavaInline|Car| er en underklasse til \JavaInline|Vehicle| klassen. \JavaInline|extends| gør det derved muligt at tilgå aspekter til en bil gennem \JavaInline|Vehicle| klassen, som ikke er direkte defineret i \JavaInline|Car| klassen og vice versa, dog kun de dele af klasserne der er public. Betydende at private attributter ikke kan tilgås i den en klasse fra den anden.

Når man gerne vil implementere en metode der allerede findes i den klasse man nedarver fra, så gøres det med at tilføje @Override lige over metode definitionen. Et eksempel på dette kan ses i \autoref{lst:inheritance-override}

\begin{JavaCode}{Eksempel på override}{lst:inheritance-override}
	@Override
	public String toString() {
		String returnString = //what you want to return goes here
		return returnString;
	}
\end{JavaCode}

\section{Objekter}

Hvad har vi allerede set af eksempler på

\subsection{Oprettelse af objekter}

Eksempel: lav bøger

\subsection{Kalde metoder på objekter}

Eksempel: get og set stuff på bog

\subsection{Casting}

\section{Klasser i Java, der er gode at kende}

\subsection{Lists}

Arraylists

\subsection{Hashmaps}
Et HashMap er næsten ligesom en Arrayliste. Det er en datastruktur. Altså en måde, at organizere en samling variabler på. Forskellen mellem en HashMap og en ArrayListe, er hvordan man tilgår de gemte variabler. En ArrayListe giver simpelt hver variabel et tal, og så kan man bruge minArrayListe.get(tal); Ved HashMaps bestemmer I hvad hver variabel har af "nøgle" til at blive tilgået. i \autoref{hashmap1} er et eksempel med en simpel telefonliste.
\begin{JavaCode}{TelefonListe}{hashmap1}
	HashMap<String, Integer> telefonliste = new HashMap<>();
	
	public void addContact(String name, int number){
		telefonliste.put(name, number);
	}
	
	public int getContact(String name){
		telefonliste.get(name);	
	}
\end{JavaCode}
Lad os gå igennem eksemplet. HashMaps skal have to typer, hvor ArrayLister kun skal have en. \marginnote{Ved en faktisk implementation ville man nok bruge en anden type til et telefonnummer for at sikre at der er 8 cifre}Dette er fordi, Hashmaps både skal kende typen af nøglen, og typen af den variabel der gemmes. Her er nøglen sat til en string, da vi forbinder de gemte telefonnumre til et navn. Og den gemte variabel er en integer for, at  der er et nummer.  For at tilføje elementer til listen bruger vi .put(nøgle, variabel); og for at få en variabel bruger vi .get(nøgle); Nøglen kan være af alle de normale typer, så man kan faktisk lave en ArrayListe med et HashMap, som bruger integers som nøgler. Yderligere funktionalitet for HashMaps kan ses i \autoref{hashmap2}
\begin{JavaCode}{Metoder for Hashmap}{hashmap2}
	ArrayList<Integer> alleNumre = telefonliste.values();
	//Faa alle variabler i hashmappet som en arrayliste
	
	telefonliste.remove("Klods Hans");
	//Fjern en variabel fra hashmappet
	
	boolean harLeasy = telefonliste.containsValue(88888888);
	//True hvis variablen ligger i hashmappet
	
	boolean harSnehvide = telefonliste.containsKey("Snehvide");
	//True hvis noeglen ligger i hashmappet
	
	telefonliste.size();
	//Antal variabler i listen
\end{JavaCode}
En sidste bemærkning er at der kun kan være en variabel for hver nøgle. Hvis du putter en varibel med en nøgle som allerede er i mappet, fjernes den gamle variabel som havde den nøgle. Altså den overskrives.

\subsection{Enumerables}
Enumerable er en speciel type klasse, hvor objekter kan være fra et specifikt defineret sæt af muligheder. Lad os demonstere med \autoref{enums1}.
%TODO fix javacode her. Ikke alt tekst kommer med
\begin{JavaCode}{Ugedage}{enums1}
	public enum Weekday{
		MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
	}
	
	if(today == Weekday.FRIDAY){
		party();
	}
\end{JavaCode}
Altså er det når man har brug for en variabeltype, som repræsenterer én mulighed ud af en gruppe af elementer. Man kan oprette en enum klasse og så oprette variabler af den type, og sætte dem til den type, og sammenligne om de er af den type. Husk at bruge EnumNavn.elementNavn istedet for bare elementNavn, når du opretter variablens værdi.

